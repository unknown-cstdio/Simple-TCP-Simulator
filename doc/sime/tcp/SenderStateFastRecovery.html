<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_09) on Mon Dec 08 14:40:43 EST 2014 -->
<title>SenderStateFastRecovery</title>
<meta name="date" content="2014-12-08">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="SenderStateFastRecovery";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/SenderStateFastRecovery.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../sime/tcp/SenderStateCongestionAvoidance.html" title="class in sime.tcp"><span class="strong">Prev Class</span></a></li>
<li><a href="../../sime/tcp/SenderStateSlowStart.html" title="class in sime.tcp"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?sime/tcp/SenderStateFastRecovery.html" target="_top">Frames</a></li>
<li><a href="SenderStateFastRecovery.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">sime.tcp</div>
<h2 title="Class SenderStateFastRecovery" class="title">Class SenderStateFastRecovery</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li><a href="../../sime/tcp/SenderState.html" title="class in sime.tcp">sime.tcp.SenderState</a></li>
<li>
<ul class="inheritance">
<li>sime.tcp.SenderStateFastRecovery</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="strong">SenderStateFastRecovery</span>
extends <a href="../../sime/tcp/SenderState.html" title="class in sime.tcp">SenderState</a></pre>
<div class="block">TCP Reno sender's state Fast Recovery.
 (TCP Tahoe does <i>not</i> have this state.)
 TCP Reno sender remains in the Fast Recovery state
 until a new ACK acknowledges <i>all</i> the data
 that were outstanding at the time when <a href="../../sime/tcp/Sender.html#dupACKthreshold"><code>Sender.dupACKthreshold</code></a>
 duplicate acknowledgments were received (and the sender entered
 this state).</div>
<dl><dt><span class="strong">Author:</span></dt>
  <dd>Ivan Marsic</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="../../sime/tcp/SenderReno.html" title="class in sime.tcp"><code>SenderReno</code></a></dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/SenderStateFastRecovery.html#firstPartialACK">firstPartialACK</a></strong></code>
<div class="block">Parameter that indicates whether this is the first
 partial ACK of the data that were outstanding when
 a data loss was detected.<br />
 Used in TCP NewReno, in method <a href="../../sime/tcp/SenderStateFastRecovery.html#calcCongWinAfterNewAck(int, int)"><code>calcCongWinAfterNewAck(int, int)</code></a>
 if the "Impatient variant" of the NewReno sender is implemented.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="fields_inherited_from_class_sime.tcp.SenderState">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;sime.tcp.<a href="../../sime/tcp/SenderState.html" title="class in sime.tcp">SenderState</a></h3>
<code><a href="../../sime/tcp/SenderState.html#after3xDupACKstate">after3xDupACKstate</a>, <a href="../../sime/tcp/SenderState.html#congestionAvoidanceState">congestionAvoidanceState</a>, <a href="../../sime/tcp/SenderState.html#sender">sender</a>, <a href="../../sime/tcp/SenderState.html#slowStartState">slowStartState</a></code></li>
</ul>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../sime/tcp/SenderStateFastRecovery.html#SenderStateFastRecovery(sime.tcp.Sender, sime.tcp.SenderState, sime.tcp.SenderState)">SenderStateFastRecovery</a></strong>(<a href="../../sime/tcp/Sender.html" title="class in sime.tcp">Sender</a>&nbsp;sender,
                       <a href="../../sime/tcp/SenderState.html" title="class in sime.tcp">SenderState</a>&nbsp;slowStartState,
                       <a href="../../sime/tcp/SenderState.html" title="class in sime.tcp">SenderState</a>&nbsp;congestionAvoidanceState)</code>
<div class="block">Constructor for the fast recovery state of a TCP Reno sender.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/SenderStateFastRecovery.html#calcCongWinAfterNewAck(int, int)">calcCongWinAfterNewAck</a></strong>(int&nbsp;ackSequenceNumber_,
                      int&nbsp;lastByteAcked_)</code>
<div class="block">Helper method to calculate the new value of the congestion
 window after a "new ACK" is received that acknowledges
 data never acknowledged before.<BR>
 This is where old TCP Reno and TCP NewReno differ.<br />
 This method also resets the RTO timer for any outstanding segments.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../sime/tcp/SenderState.html" title="class in sime.tcp">SenderState</a></code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/SenderStateFastRecovery.html#handleDupACK(sime.tcp.Segment)">handleDupACK</a></strong>(<a href="../../sime/tcp/Segment.html" title="class in sime.tcp">Segment</a>&nbsp;dupAck_)</code>
<div class="block">This method handles a duplicate acknowledgment
 during <em>fast recovery</em>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../sime/tcp/SenderState.html" title="class in sime.tcp">SenderState</a></code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/SenderStateFastRecovery.html#lookupNextStateAfterNewAck()">lookupNextStateAfterNewAck</a></strong>()</code>
<div class="block">Helper method to return the next state after a "new ACK".</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_sime.tcp.SenderState">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;sime.tcp.<a href="../../sime/tcp/SenderState.html" title="class in sime.tcp">SenderState</a></h3>
<code><a href="../../sime/tcp/SenderState.html#handleNewACK(sime.tcp.Segment)">handleNewACK</a>, <a href="../../sime/tcp/SenderState.html#handleRTOtimeout(sime.tcp.Segment)">handleRTOtimeout</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="firstPartialACK">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>firstPartialACK</h4>
<pre>protected&nbsp;boolean firstPartialACK</pre>
<div class="block">Parameter that indicates whether this is the first
 partial ACK of the data that were outstanding when
 a data loss was detected.<br />
 Used in TCP NewReno, in method <a href="../../sime/tcp/SenderStateFastRecovery.html#calcCongWinAfterNewAck(int, int)"><code>calcCongWinAfterNewAck(int, int)</code></a>
 if the "Impatient variant" of the NewReno sender is implemented.
 (see <a href="http://tools.ietf.org/html/rfc3782" target="page">RFC 3782</a>).</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="SenderStateFastRecovery(sime.tcp.Sender, sime.tcp.SenderState, sime.tcp.SenderState)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>SenderStateFastRecovery</h4>
<pre>public&nbsp;SenderStateFastRecovery(<a href="../../sime/tcp/Sender.html" title="class in sime.tcp">Sender</a>&nbsp;sender,
                       <a href="../../sime/tcp/SenderState.html" title="class in sime.tcp">SenderState</a>&nbsp;slowStartState,
                       <a href="../../sime/tcp/SenderState.html" title="class in sime.tcp">SenderState</a>&nbsp;congestionAvoidanceState)</pre>
<div class="block">Constructor for the fast recovery state of a TCP Reno sender.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sender</code> - </dd><dd><code>slowStartState</code> - Slow start state</dd><dd><code>congestionAvoidanceState</code> - Congestion avoidance state</dd></dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="calcCongWinAfterNewAck(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calcCongWinAfterNewAck</h4>
<pre>protected&nbsp;int&nbsp;calcCongWinAfterNewAck(int&nbsp;ackSequenceNumber_,
                         int&nbsp;lastByteAcked_)</pre>
<div class="block">Helper method to calculate the new value of the congestion
 window after a "new ACK" is received that acknowledges
 data never acknowledged before.<BR>
 This is where old TCP Reno and TCP NewReno differ.<br />
 This method also resets the RTO timer for any outstanding segments.</p>
 
 <p><a href="http://tools.ietf.org/html/rfc2581" target="page">RFC 2581</a> for
 TCP Reno in Section 3.2 Fast Retransmit/Fast Recovery
 in Step 5 says:
 &ldquo;<i>When the next ACK arrives that acknowledges new data,
 ... this ACK should acknowledge all the intermediate
 segments sent between the lost segment and the receipt of the
 third duplicate ACK, if none of these were lost.</i>&rdquo;<BR>
 But, it does't say what if this is not true.</P>
 
 <P>The answer is that the <i>old</i> Reno simply exits
 fast recovery when it receives an ACK for previously
 unacknowledged data (known as a "recovery ACK"), and that is what
 <a href="http://tools.ietf.org/html/rfc2581" target="page">RFC 2581</a>
 says about processing new ACKs during Fast Recovery.</p>
 
 <P>Unlike this, TCP <b>NewReno</b> sender
 distinguishes "partial acknowledgments"
 as defined in <a href="http://tools.ietf.org/html/rfc3782" target="page">RFC 3782</a>
 (ACKs that cover previously unacknowledged data, but
 not all the data outstanding when loss was detected). The sender
 remains in Fast Recovery until a new ACK acknowledges <i>all</i>
 the data outstanding at the time when <a href="../../sime/tcp/Sender.html#dupACKthreshold"><code>Sender.dupACKthreshold</code></a>
 dupACKs were received.<BR>
 Only when the NewReno sender receives a "full ACK",
 it behaves the same as old Reno, and exits Fast Recovery.<BR>
 Whether the new ACK is "partial" or "full" is determined
 by comparing it to the parameter
 <a href="../../sime/tcp/Sender.html#lastByteSentBefore3xDupAcksRecvd"><code>Sender.lastByteSentBefore3xDupAcksRecvd</code></a>.</p>
 
 <p><a href="http://tools.ietf.org/html/rfc5681" target="page">RFC 5681</a>
 (in Section 3.2) states that the retransmit timer should be reset
 only for the <em>first partial ACK</em> that arrives during fast recovery
 (applies only to TCP NewReno).
 Timer management in <b>NewReno</b> is discussed in more detail in Section 4 of RFC 5681.<br />
 Our simplified implementation resets the RTO timer for every partial ACK. </p></div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../sime/tcp/SenderState.html#calcCongWinAfterNewAck(int, int)">calcCongWinAfterNewAck</a></code>&nbsp;in class&nbsp;<code><a href="../../sime/tcp/SenderState.html" title="class in sime.tcp">SenderState</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>ackSequenceNumber_</code> - acknowledged data sequence number</dd><dd><code>lastByteAcked_</code> - last byte previously acknowledged (not yet updated with this new ACK!)</dd>
<dt><span class="strong">Returns:</span></dt><dd>the new value of the congestion window</dd></dl>
</li>
</ul>
<a name="handleDupACK(sime.tcp.Segment)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>handleDupACK</h4>
<pre>public&nbsp;<a href="../../sime/tcp/SenderState.html" title="class in sime.tcp">SenderState</a>&nbsp;handleDupACK(<a href="../../sime/tcp/Segment.html" title="class in sime.tcp">Segment</a>&nbsp;dupAck_)</pre>
<div class="block">This method handles a duplicate acknowledgment
 during <em>fast recovery</em>. All it does is to
 inflate the congestion window by one <tt>MSS</tt>.<BR>
 Note that it overrides the base class method
 <a href="../../sime/tcp/SenderState.html#handleDupACK(sime.tcp.Segment)"><code>SenderState.handleDupACK(Segment)</code></a>.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../sime/tcp/SenderState.html#handleDupACK(sime.tcp.Segment)">handleDupACK</a></code>&nbsp;in class&nbsp;<code><a href="../../sime/tcp/SenderState.html" title="class in sime.tcp">SenderState</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dupAck_</code> - The duplicate acknowledgment to process.</dd>
<dt><span class="strong">Returns:</span></dt><dd>Returns the new state to which the sender will
 transition after the dupACK event (may be this same state).</dd></dl>
</li>
</ul>
<a name="lookupNextStateAfterNewAck()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>lookupNextStateAfterNewAck</h4>
<pre>protected&nbsp;<a href="../../sime/tcp/SenderState.html" title="class in sime.tcp">SenderState</a>&nbsp;lookupNextStateAfterNewAck()</pre>
<div class="block">Helper method to return the next state after a "new ACK".
 After fast recovery, Reno sender always enters
 the congestion avoidance state.<BR>
 Note that NewReno distinguishes "partial acknowledgments"
 as defined in <a href="http://tools.ietf.org/html/rfc3782" target="page">RFC 3782</a>
 (ACKs that cover previously unacknowledged data, but
 not all the data outstanding when loss was detected).</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../sime/tcp/SenderState.html#lookupNextStateAfterNewAck()">lookupNextStateAfterNewAck</a></code>&nbsp;in class&nbsp;<code><a href="../../sime/tcp/SenderState.html" title="class in sime.tcp">SenderState</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>the next state to transition to.</dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/SenderStateFastRecovery.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../sime/tcp/SenderStateCongestionAvoidance.html" title="class in sime.tcp"><span class="strong">Prev Class</span></a></li>
<li><a href="../../sime/tcp/SenderStateSlowStart.html" title="class in sime.tcp"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?sime/tcp/SenderStateFastRecovery.html" target="_top">Frames</a></li>
<li><a href="SenderStateFastRecovery.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
