<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_09) on Mon Dec 08 14:40:42 EST 2014 -->
<title>Receiver</title>
<meta name="date" content="2014-12-08">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Receiver";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Receiver.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev Class</li>
<li><a href="../../sime/tcp/RTOEstimator.html" title="class in sime.tcp"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?sime/tcp/Receiver.html" target="_top">Frames</a></li>
<li><a href="Receiver.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">sime.tcp</div>
<h2 title="Class Receiver" class="title">Class Receiver</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>sime.tcp.Receiver</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><a href="../../sime/TimedComponent.html" title="interface in sime">TimedComponent</a></dd>
</dl>
<hr>
<br>
<pre>public class <span class="strong">Receiver</span>
extends java.lang.Object
implements <a href="../../sime/TimedComponent.html" title="interface in sime">TimedComponent</a></pre>
<div class="block">This class implements a simple TCP receiver protocol module.<BR>
 I tried to follow the specification in
 <a href="http://tools.ietf.org/html/rfc5681" target="page">RFC 5681</a>
 and <a href="http://www.apps.ietf.org/rfc/rfc2581.html" target="page">RFC 2581</a>
 as closely as I could. However, some intricate details are left out.
 In particular, because this is a simple discrete-time simulator
 and the clock tick granularity is very coarse (one tick equals
 one round-trip time (RTT)), the delayed-ACKs timer is not
 implemented as recommended. See more discussion related to
 <a href="../../sime/tcp/Receiver.html#delayedACKtimer"><code>delayedACKtimer</code></a> and <a href="../../sime/tcp/Receiver.html#cumulativeACK"><code>cumulativeACK</code></a>.</div>
<dl><dt><span class="strong">Author:</span></dt>
  <dd>Ivan Marsic</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="../../sime/Simulator.html" title="class in sime"><code>Simulator</code></a></dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../sime/tcp/Segment.html" title="class in sime.tcp">Segment</a></code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/Receiver.html#cumulativeACK">cumulativeACK</a></strong></code>
<div class="block">The receiver may hold a cumulative acknowledgment
 for in-order segments, to acknowledge several consecutive
 segments at once.<BR>
 There are two standard methods that can be used by TCP receivers to
 generate acknowledgments.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/Receiver.html#currentRcvWindow">currentRcvWindow</a></strong></code>
<div class="block">Current receive window size, in bytes.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../sime/TimerSimulated.html" title="class in sime">TimerSimulated</a></code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/Receiver.html#delayedACKtimer">delayedACKtimer</a></strong></code>
<div class="block">The timer for delayed (cumulative) acknowledgments.<BR>
 Because of the way the simulator is implemented, it calls
 the receiver to process the received packets one by one.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../sime/TimerSimulated.html" title="class in sime">TimerSimulated</a></code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/Receiver.html#delayedACKtimerHandle">delayedACKtimerHandle</a></strong></code>
<div class="block">Handle returned by the simulator, in case <a href="../../sime/tcp/Receiver.html#delayedACKtimer"><code>delayedACKtimer</code></a>
 needs to be canceled.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/Receiver.html#lastByteRecvd">lastByteRecvd</a></strong></code>
<div class="block">The field records the last byte received in-sequence.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>(package private) <a href="../../sime/Endpoint.html" title="class in sime">Endpoint</a></code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/Receiver.html#localEndpoint">localEndpoint</a></strong></code>
<div class="block">Local endpoint that contains this receiver object.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/Receiver.html#maxRcvWindowSize">maxRcvWindowSize</a></strong></code>
<div class="block">Maximum receive window size, in bytes.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/Receiver.html#nextByteExpected">nextByteExpected</a></strong></code>
<div class="block">The next byte currently expected from the sender.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.util.ArrayList&lt;<a href="../../sime/tcp/Segment.html" title="class in sime.tcp">Segment</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/Receiver.html#rcvBuffer">rcvBuffer</a></strong></code>
<div class="block">The receiver buffer to buffer the segments that arrive
 out-of-sequence.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../sime/tcp/Receiver.html#Receiver(sime.Endpoint, int)">Receiver</a></strong>(<a href="../../sime/Endpoint.html" title="class in sime">Endpoint</a>&nbsp;localTCPendpoint_,
        int&nbsp;rcvWindowSize_)</code>
<div class="block">Constructor.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/Receiver.html#checkBufferedSegments()">checkBufferedSegments</a></strong>()</code>
<div class="block">Helper method, checks if the newly received segment(s)
 fill a gap for the segments that were previously
 received out-of-sequence and are stored in a temporary
 storage ("buffered").</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/Receiver.html#getRcvWindow()">getRcvWindow</a></strong>()</code>
<div class="block">Returns the receive window size for this receiver, in bytes.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/Receiver.html#handle(sime.tcp.Segment)">handle</a></strong>(<a href="../../sime/tcp/Segment.html" title="class in sime.tcp">Segment</a>&nbsp;segment_)</code>
<div class="block">Receives the segments from the sender, passes the
 ones that arrived error-free and in-order to the application.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../sime/tcp/Segment.html" title="class in sime.tcp">Segment</a></code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/Receiver.html#handleOutOfSequenceSegment(sime.tcp.Segment)">handleOutOfSequenceSegment</a></strong>(<a href="../../sime/tcp/Segment.html" title="class in sime.tcp">Segment</a>&nbsp;segment_)</code>
<div class="block">Helper method to handle out-of-sequence segments.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/Receiver.html#sendCumulativeAcknowledgement()">sendCumulativeAcknowledgement</a></strong>()</code>
<div class="block">Helper method to transmit a cumulative acknowledgment.<BR>
 The TCP specification suggests that at <em>least every other</em>
 acknowledgment should be sent.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../sime/tcp/Receiver.html#timerExpired(int)">timerExpired</a></strong>(int&nbsp;timerType_)</code>
<div class="block">Callback method to call when a simulated timer expires.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="cumulativeACK">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cumulativeACK</h4>
<pre>protected&nbsp;<a href="../../sime/tcp/Segment.html" title="class in sime.tcp">Segment</a> cumulativeACK</pre>
<div class="block">The receiver may hold a cumulative acknowledgment
 for in-order segments, to acknowledge several consecutive
 segments at once.<BR>
 There are two standard methods that can be used by TCP receivers to
 generate acknowledgments. The method outlined in
 <a href="http://tools.ietf.org/html/rfc793" target="page">RFC 793</a> generates
 an ACK for each incoming data segment (including in-order segments).
 <a href="http://tools.ietf.org/html/rfc1122" target="page">RFC 1122</a> states
 that hosts should use "delayed acknowledgments" for in-order segments.
 Using this approach, an ACK is generated for at least every second in-order,
 full-sized segment, or if a second full-sized segment does not arrive
 within a given timeout (which must not exceed 500 ms [RFC 1122],  and
 is typically less than 200 ms).
 Such approach is also adopted in
 <a href="http://tools.ietf.org/html/rfc2581" target="page">RFC 2581</a>.
 <BR><a href="http://tools.ietf.org/html/rfc2760" target="page">RFC 2760</a>
 also allows to generate <em>Stretch ACKs</em> that acknowledge more
 than two in-order full-sized segments. This approach
 provides a possible mitigation, which reduces the rate at which ACKs
 are returned by the receiver. The interested reader should check for
 discussion of modified delayed ACKs in
 <a href="http://tools.ietf.org/html/rfc3449" target="page">RFC 3449</a>
 in Section 4.1.</div>
</li>
</ul>
<a name="currentRcvWindow">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>currentRcvWindow</h4>
<pre>protected&nbsp;int currentRcvWindow</pre>
<div class="block">Current receive window size, in bytes. Varies depending
 on whether any out-of-order segments are currently buffered.</div>
</li>
</ul>
<a name="delayedACKtimer">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>delayedACKtimer</h4>
<pre>protected&nbsp;<a href="../../sime/TimerSimulated.html" title="class in sime">TimerSimulated</a> delayedACKtimer</pre>
<div class="block">The timer for delayed (cumulative) acknowledgments.<BR>
 Because of the way the simulator is implemented, it calls
 the receiver to process the received packets one by one.
 An out-of-order packet must be acknowledged immediately
 by a duplicate ACK. However, for in-order packets a
 cumulative ACK will be maintained that will be sent
 only when this timer expires.</p>
 <a href="http://tools.ietf.org/html/rfc2581" target="page">RFC 2581</a>
 says that an ACK should be generated for at least every
 second full-sized segment, and must be generated within
 500 ms of the arrival of the first unacknowledged packet.
 Therefore, the receiver can send an ACK for no more than
 two data packets arriving in-order. See more information
 related to <a href="../../sime/tcp/Receiver.html#cumulativeACK"><code>cumulativeACK</code></a>.</div>
</li>
</ul>
<a name="delayedACKtimerHandle">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>delayedACKtimerHandle</h4>
<pre>protected&nbsp;<a href="../../sime/TimerSimulated.html" title="class in sime">TimerSimulated</a> delayedACKtimerHandle</pre>
<div class="block">Handle returned by the simulator, in case <a href="../../sime/tcp/Receiver.html#delayedACKtimer"><code>delayedACKtimer</code></a>
 needs to be canceled. Recall that, if the receiver receives
 an out-of-order segment, it is obliged to send a (duplicate)
 ACK immediately. However, if <a href="../../sime/tcp/Receiver.html#delayedACKtimer"><code>delayedACKtimer</code></a> has
 not yet expired, it must be cancelled first.</div>
</li>
</ul>
<a name="lastByteRecvd">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lastByteRecvd</h4>
<pre>protected&nbsp;int lastByteRecvd</pre>
<div class="block">The field records the last byte received in-sequence.
 Recall that the bytes are numbered from zero, so the sequence
 number of the first byte is zero, etc.</div>
</li>
</ul>
<a name="localEndpoint">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>localEndpoint</h4>
<pre><a href="../../sime/Endpoint.html" title="class in sime">Endpoint</a> localEndpoint</pre>
<div class="block">Local endpoint that contains this receiver object.</div>
</li>
</ul>
<a name="maxRcvWindowSize">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>maxRcvWindowSize</h4>
<pre>protected&nbsp;int maxRcvWindowSize</pre>
<div class="block">Maximum receive window size, in bytes. This is how
 much memory this receiver allocated for a temporary
 storage ("buffer") for holding out-of-order segments.</div>
</li>
</ul>
<a name="nextByteExpected">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nextByteExpected</h4>
<pre>protected&nbsp;int nextByteExpected</pre>
<div class="block">The next byte currently expected from the sender.
 Recall that the bytes are numbered from zero, so the sequence
 number of the first byte is zero, etc.</div>
</li>
</ul>
<a name="rcvBuffer">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>rcvBuffer</h4>
<pre>protected&nbsp;java.util.ArrayList&lt;<a href="../../sime/tcp/Segment.html" title="class in sime.tcp">Segment</a>&gt; rcvBuffer</pre>
<div class="block">The receiver buffer to buffer the segments that arrive
 out-of-sequence. Note that, ideally, this list should always be
 sorted in the ascending order of sequence numbers of the
 currently buffered segments. Having it sorted makes for
 easier processing of gap-filling segments in
 <a href="../../sime/tcp/Receiver.html#checkBufferedSegments()"><code>checkBufferedSegments()</code></a>.</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Receiver(sime.Endpoint, int)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Receiver</h4>
<pre>public&nbsp;Receiver(<a href="../../sime/Endpoint.html" title="class in sime">Endpoint</a>&nbsp;localTCPendpoint_,
        int&nbsp;rcvWindowSize_)</pre>
<div class="block">Constructor.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>localTCPendpoint_</code> - The local TCP endpoint object that contains
 this receiver.</dd><dd><code>rcvWindowSize_</code> - The maximum receive window size, in bytes
 &mdash; how much memory this receiver should allocate for buffering
 out-of-order segments.</dd></dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="checkBufferedSegments()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkBufferedSegments</h4>
<pre>protected&nbsp;void&nbsp;checkBufferedSegments()</pre>
<div class="block">Helper method, checks if the newly received segment(s)
 fill a gap for the segments that were previously
 received out-of-sequence and are stored in a temporary
 storage ("buffered").
 These segments are waiting for the gap to be filled.
 Once an arriving segment fills the gap, the first buffered
 segment will become "next expected segment".
 That is the condition for which this method checks.
 If what is currently the "next expected segment" is one of
 already buffered segments (received earlier), this method
 removes that segment from the receive buffer and delivers
 it to the receiving application.</div>
</li>
</ul>
<a name="getRcvWindow()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRcvWindow</h4>
<pre>public&nbsp;int&nbsp;getRcvWindow()</pre>
<div class="block">Returns the receive window size for this receiver, in bytes.</div>
</li>
</ul>
<a name="handle(sime.tcp.Segment)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>handle</h4>
<pre>public&nbsp;void&nbsp;handle(<a href="../../sime/tcp/Segment.html" title="class in sime.tcp">Segment</a>&nbsp;segment_)</pre>
<div class="block">Receives the segments from the sender, passes the
 ones that arrived error-free and in-order to the application.
 Buffers the ones that arrived out-of-sequence.<BR>
 The receiver quietly discards a packet that arrived with
 a checksum error.</p>
 
 <p>The receiver returns <i>cumulative</i> acknowledgments,
 which means that if the newly received segment fills the
 gap created by out-of-sequence segments that were received
 earlier, the cumulative ACK will acknowledge those earlier
 segments, as well.
 <P>
 The value <code>null</code> of the <code>segments_</code> input
 array element means that the corresponding segment was
 <i>lost</i> in transport (i.e., at the Router).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>segment_</code> - The received segments (with non-zero data payload).</dd></dl>
</li>
</ul>
<a name="handleOutOfSequenceSegment(sime.tcp.Segment)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>handleOutOfSequenceSegment</h4>
<pre>protected&nbsp;<a href="../../sime/tcp/Segment.html" title="class in sime.tcp">Segment</a>&nbsp;handleOutOfSequenceSegment(<a href="../../sime/tcp/Segment.html" title="class in sime.tcp">Segment</a>&nbsp;segment_)</pre>
<div class="block">Helper method to handle out-of-sequence segments.
 Such segments are buffered in the <a href="../../sime/tcp/Receiver.html#rcvBuffer"><code>rcvBuffer</code></a>.
 The returned value will be a <i>duplicate acknowledgment</i>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>segment_</code> - The segment that is currently being processed
 (i.e., the seq. num. of the segment's last byte).</dd>
<dt><span class="strong">Returns:</span></dt><dd>Returns the acknowledgment segment for the input data segment.</dd></dl>
</li>
</ul>
<a name="sendCumulativeAcknowledgement()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sendCumulativeAcknowledgement</h4>
<pre>protected&nbsp;void&nbsp;sendCumulativeAcknowledgement()</pre>
<div class="block">Helper method to transmit a cumulative acknowledgment.<BR>
 The TCP specification suggests that at <em>least every other</em>
 acknowledgment should be sent. However, for the lack of time,
 this implementation sends whatever accumulates within
 the delayed-ACK timer <a href="../../sime/tcp/Receiver.html#delayedACKtimer"><code>delayedACKtimer</code></a> time.</div>
</li>
</ul>
<a name="timerExpired(int)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>timerExpired</h4>
<pre>public&nbsp;void&nbsp;timerExpired(int&nbsp;timerType_)</pre>
<div class="block">Callback method to call when a simulated timer expires. </p>
 
 <p>Currently, the receiver sets a timer
 for delayed (cumulative) acknowledgments.
 Any cumulative ACK that it may be holding
 will be transmitted now.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../sime/TimedComponent.html#timerExpired(int)">timerExpired</a></code>&nbsp;in interface&nbsp;<code><a href="../../sime/TimedComponent.html" title="interface in sime">TimedComponent</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>timerType_</code> - type of the timer set initially by the caller,
 in case multiple timers are run by the same component.</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../sime/TimedComponent.html" title="interface in sime"><code>TimedComponent</code></a></dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Receiver.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev Class</li>
<li><a href="../../sime/tcp/RTOEstimator.html" title="class in sime.tcp"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?sime/tcp/Receiver.html" target="_top">Frames</a></li>
<li><a href="Receiver.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
